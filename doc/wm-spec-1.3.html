<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Extended Window Manager Hints</title><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="index"></a>Extended Window Manager Hints</h2></div><div><div class="authorgroup"><h3 class="corpauthor">
      <a class="ulink" href="http://www.freedesktop.org" target="_top">X Desktop Group</a>
      </h3></div></div><div><p class="releaseinfo">Final version 1.3</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2721765">Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2721771">Version</a></span></dt><dt><span class="sect2"><a href="#id2683843">What is this spec?</a></span></dt><dt><span class="sect2"><a href="#id2683868">Language used in this specification</a></span></dt><dt><span class="sect2"><a href="#id2683156">Prerequisites for adoption of this specification</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2683172">Non-ICCCM features</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2683184">Additional States</a></span></dt><dt><span class="sect2"><a href="#id2721851">Modality</a></span></dt><dt><span class="sect2"><a href="#largedesks">Large Desktops</a></span></dt><dt><span class="sect2"><a href="#id2688123">Sticky windows</a></span></dt><dt><span class="sect2"><a href="#id2688137">Virtual Desktops</a></span></dt><dt><span class="sect2"><a href="#id2688204">Pagers</a></span></dt><dt><span class="sect2"><a href="#id2682511">Taskbars</a></span></dt><dt><span class="sect2"><a href="#activation">Activation</a></span></dt><dt><span class="sect2"><a href="#id2682546">Animated iconification</a></span></dt><dt><span class="sect2"><a href="#id2682561">Window-in-window MDI</a></span></dt><dt><span class="sect2"><a href="#id2682577">Layered stacking order</a></span></dt><dt><span class="sect2"><a href="#id2682599">Scope of this spec</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2687642">Root Window Properties (and Related Messages)</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2687662">_NET_SUPPORTED</a></span></dt><dt><span class="sect2"><a href="#id2687686">_NET_CLIENT_LIST</a></span></dt><dt><span class="sect2"><a href="#id2687708">_NET_NUMBER_OF_DESKTOPS</a></span></dt><dt><span class="sect2"><a href="#id2687765">_NET_DESKTOP_GEOMETRY</a></span></dt><dt><span class="sect2"><a href="#id2687806">_NET_DESKTOP_VIEWPORT</a></span></dt><dt><span class="sect2"><a href="#id2687845">_NET_CURRENT_DESKTOP</a></span></dt><dt><span class="sect2"><a href="#id2731041">_NET_DESKTOP_NAMES</a></span></dt><dt><span class="sect2"><a href="#id2731082">_NET_ACTIVE_WINDOW</a></span></dt><dt><span class="sect2"><a href="#id2731133">_NET_WORKAREA</a></span></dt><dt><span class="sect2"><a href="#id2731172">_NET_SUPPORTING_WM_CHECK</a></span></dt><dt><span class="sect2"><a href="#id2731204">_NET_VIRTUAL_ROOTS</a></span></dt><dt><span class="sect2"><a href="#id2731226">_NET_DESKTOP_LAYOUT</a></span></dt><dt><span class="sect2"><a href="#id2731380">_NET_SHOWING_DESKTOP</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2731418">Other Root Window Messages</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2731423">_NET_CLOSE_WINDOW</a></span></dt><dt><span class="sect2"><a href="#id2731465">_NET_MOVERESIZE_WINDOW</a></span></dt><dt><span class="sect2"><a href="#id2731519">_NET_WM_MOVERESIZE</a></span></dt><dt><span class="sect2"><a href="#id2731571">_NET_RESTACK_WINDOW</a></span></dt><dt><span class="sect2"><a href="#id2731636">_NET_REQUEST_FRAME_EXTENTS</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2731686">Application Window Properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2731691">_NET_WM_NAME</a></span></dt><dt><span class="sect2"><a href="#id2731708">_NET_WM_VISIBLE_NAME</a></span></dt><dt><span class="sect2"><a href="#id2731743">_NET_WM_ICON_NAME</a></span></dt><dt><span class="sect2"><a href="#id2731760">_NET_WM_VISIBLE_ICON_NAME</a></span></dt><dt><span class="sect2"><a href="#id2731778">_NET_WM_DESKTOP</a></span></dt><dt><span class="sect2"><a href="#id2731840">_NET_WM_WINDOW_TYPE</a></span></dt><dt><span class="sect2"><a href="#id2731936">_NET_WM_STATE</a></span></dt><dt><span class="sect2"><a href="#id2732155">_NET_WM_ALLOWED_ACTIONS</a></span></dt><dt><span class="sect2"><a href="#id2732272">_NET_WM_STRUT</a></span></dt><dt><span class="sect2"><a href="#id2732296">_NET_WM_STRUT_PARTIAL</a></span></dt><dt><span class="sect2"><a href="#id2732383">_NET_WM_ICON_GEOMETRY</a></span></dt><dt><span class="sect2"><a href="#id2732407">_NET_WM_ICON</a></span></dt><dt><span class="sect2"><a href="#id2732434">_NET_WM_PID</a></span></dt><dt><span class="sect2"><a href="#id2732475">_NET_WM_HANDLED_ICONS</a></span></dt><dt><span class="sect2"><a href="#id2732493">_NET_WM_USER_TIME</a></span></dt><dt><span class="sect2"><a href="#id2732545">_NET_FRAME_EXTENTS</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2732565">Window Manager Protocols</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2732570">_NET_WM_PING</a></span></dt><dt><span class="sect2"><a href="#id2732629">_NET_WM_SYNC_REQUEST</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2732704">Implementation notes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2732709">Desktop/workspace model</a></span></dt><dt><span class="sect2"><a href="#id2732723">File Manager desktop</a></span></dt><dt><span class="sect2"><a href="#id2732741">Implementing enhanced support for application transient windows</a></span></dt><dt><span class="sect2"><a href="#URGENCY">Urgency</a></span></dt><dt><span class="sect2"><a href="#NORESIZE">Fixed size windows</a></span></dt><dt><span class="sect2"><a href="#id2732788">Pagers and Taskbars</a></span></dt><dt><span class="sect2"><a href="#id2732857">Window Geometry</a></span></dt><dt><span class="sect2"><a href="#id2733264">Window-in-Window MDI</a></span></dt><dt><span class="sect2"><a href="#KILLINGWINDOWS">Killing Hung Processes</a></span></dt><dt><span class="sect2"><a href="#STACKINGORDER">Stacking order</a></span></dt><dt><span class="sect2"><a href="#sourceindication">Source indication in requests</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2733403">References</a></span></dt><dt><span class="sect1"><a href="#id2733447">Copyright</a></span></dt><dt><span class="sect1"><a href="#id2733485">Contributors</a></span></dt><dt><span class="sect1"><a href="#id2733572">Change history</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2733578">Changes since 1.2</a></span></dt><dt><span class="sect2"><a href="#id2733686">Changes since 1.1</a></span></dt><dt><span class="sect2"><a href="#id2733787">Changes since 1.0</a></span></dt><dt><span class="sect2"><a href="#id2733835">Changes since 1.0pre5</a></span></dt><dt><span class="sect2"><a href="#id2733867">Changes since 1.0pre4</a></span></dt><dt><span class="sect2"><a href="#id2733918">Changes since 1.0pre3</a></span></dt><dt><span class="sect2"><a href="#id2734014">Changes since 1.0pre2</a></span></dt><dt><span class="sect2"><a href="#id2734072">Changes since 1.0pre1</a></span></dt><dt><span class="sect2"><a href="#id2734093">Changes since 1.9f</a></span></dt><dt><span class="sect2"><a href="#id2734146">Changes since 1.9e</a></span></dt><dt><span class="sect2"><a href="#id2734181">Changes since 1.9d</a></span></dt><dt><span class="sect2"><a href="#id2734213">Changes since 1.9c</a></span></dt><dt><span class="sect2"><a href="#id2734305">Changes since 1.9b</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2721765"></a>Introduction</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2721771"></a>Version</h3></div></div></div><p>
This is Final version 1.3 of the Extended Window Manager Hints (EWMH) spec, updated
May 13, 2005. The canonical home for this document is <a class="ulink" href="http://www.freedesktop.org/standards/wm-spec/" target="_top">http://www.freedesktop.org</a>,
which also contains directions for reporting bugs or contributing to future
versions.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2683843"></a>What is this spec?</h3></div></div></div><p>
This spec defines interactions between window managers, applications,
and the utilities that form part of a desktop environment.  It builds
on the Inter-Client Communication Conventions Manual [<span class="citation"><a class="link" href="#ICCCM">ICCCM</a></span>], which defines  
window manager interactions at a lower level. The ICCCM does not provide ways
to implement many features that modern desktop users expect. The GNOME and KDE
desktop projects originally developed their own extensions to the ICCCM to
support these features; this spec replaces those custom extensions
with a standardized set of ICCCM additions that any desktop
environment can adopt.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2683868"></a>Language used in this specification</h3></div></div></div><p>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be
interpreted as described in RFC 2119.  
		</p><p>
The key words "Window Manager" refer to a window manager which is adopting this
specification.  "Pager" refers to desktop utility applications, including
pagers and taskbars.  "Application" refers to other clients.  "Clients" refers
to Pagers and Applications ie. all X clients, except for the Window Manager.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2683156"></a>Prerequisites for adoption of this specification</h3></div></div></div><p>
Window Managers and Clients which aim to fulfill this specification MUST adhere 
to the ICCCM on which this specification builds. If this specification 
explicitly modifies the ICCCM Window Managers and Clients MUST fulfill these 
modifications.
		</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2683172"></a>Non-ICCCM features</h2></div></div></div><p>There is a number of window management features or behaviors which are 
not specified in the ICCCM, but are commonly met in modern window managers and desktop environments.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2683184"></a>Additional States</h3></div></div></div><p>The ICCCM allows window managers to implement additional window states, which will 
appear to clients as substates of NormalState and IconicState.  Two 
commonly met examples are Maximized and Shaded.  A window manager may implement these
as proper substates of NormalState and IconicState, or it may treat them 
as independent flags, allowing e.g. a maximized window to be iconified
and to re-appear as maximized upon de-iconification.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2721808"></a>Maximization</h4></div></div></div><p>Maximization is a very old feature of window managers.  There was even a ZoomedState
in early ICCCM drafts.  Maximizing a window should give it as much of the
screen area as possible (this may not be the full screen area, but only
a smaller 'workarea', since the window manager may have reserved certain areas for other 
windows).  A window manager is expected to remember the geometry of a maximized window 
and restore it upon de-maximization.  Modern window managers typically allow separate 
horizontal and vertical maximization.</p><p>With the introduction of the Xinerama extension in X11 R6.4, maximization
has become more involved.  Xinerama allows a screen to span multiple 
monitors in a freely configurable geometry.  In such a setting, maximizing 
a window would ideally not grow it to fill the whole screen, but only the 
monitor it is shown on.  There are of course borderline cases for windows 
crossing monitor boundaries, and 'real' maximization to the full screen may 
sometimes be useful.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2721835"></a>Shading</h4></div></div></div><p>Some desktop environments offer shading (also known as rollup) as an alternative to 
iconification. A shaded window typically shows only the titlebar, the client 
window is hidden, thus shading is not useful for windows which are not 
decorated with a titlebar.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2721851"></a>Modality</h3></div></div></div><p>The WM_TRANSIENT_FOR hint of the ICCCM allows clients to specify that a 
toplevel window may be closed before the client finishes.  A typical example 
of a transient window is a dialog.  Some dialogs can be open for a long time,  
while the user continues to work in the main window.  Other dialogs have to be 
closed before the user can continue to work in the main window.  This property 
is called modality.  While clients can implement modal windows in an ICCCM 
compliant way using the globally active input model, some window managers offer support 
for handling modality.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="largedesks"></a>Large Desktops</h3></div></div></div><p>The window manager may offer to arrange the managed windows on a desktop that is 
larger than the root window. The screen functions as a viewport on this large 
desktop. Different policies regarding the positioning of the viewport on the 
desktop can be implemented:  The window manager may only allow the viewport 
position to change in increments of the screen size (paging) or it may allow
arbitrary positions (scrolling).</p><p>To fulfill the ICCCM principle that clients should behave the same
regardless whether a window manager is running or not, window managers which 
implement large desktops must interpret all client-provided geometries with 
respect to the current viewport.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="largedesksimpl"></a>Implementation note</h4></div></div></div><p>There are two options for implementing a large desktop: The first is to 
keep the managed windows (or, if reparenting, their frames) as children
of the root window.  Moving the viewport is achieved by moving all managed
windows in the opposite direction.</p><p>The second alternative is to reparent all managed windows to a dedicated 
large window (somewhat inappropriately called a 'virtual root').  Moving 
the viewport is then achieved by moving the virtual root in the opposite 
direction.</p><p>Both alternatives are completely ICCCM compliant, although the second one 
may be somewhat problematic for clients trying to figure out the window manager decorations
around their toplevel windows and for clients trying to draw background 
images on the root window.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2688123"></a>Sticky windows</h3></div></div></div><p>A window manager which implements a large desktop typically offers a way for the user 
to make certain windows 'stick to the glass', i.e. these windows will stay 
at the same position on the screen when the viewport is moved.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2688137"></a>Virtual Desktops</h3></div></div></div><p>Most X servers have only a single screen.  The window manager may virtualize this 
resource and offer multiple so-called 'virtual desktops', of which only one 
can be shown on the screen at a time.  There is some variation among the 
features of virtual desktop implementations.  There may be a fixed number 
of desktops, or new ones may be created dynamically.  The size of the desktops 
may be fixed or variable.  If the desktops are larger than the root window, 
their viewports (see <a class="xref" href="#largedesks" title="Large Desktops">the section called &#8220;Large Desktops&#8221;</a>) may be independent or forced
to be at the same position.</p><p>A window manager which implements virtual desktops generally offers a way for the user
to move clients between desktops.  Clients may be allowed to occupy more than
one desktop simultaneously.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2688167"></a>Implementation note</h4></div></div></div><p>There are at least two options for implementing virtual desktops.  
The first is to use multiple virtual roots (see <a class="xref" href="#largedesksimpl" title="Implementation note">the section called &#8220;Implementation note&#8221;</a>) and change the current 
desktop by manipulating the stacking order of the virtual roots.  This is 
completely ICCCM compliant, but has the issues outlined in <a class="xref" href="#largedesksimpl" title="Implementation note">the section called &#8220;Implementation note&#8221;</a></p><p>The second option is to keep all managed windows as children of the root 
window and unmap the frames of those which are not on the current
desktop. Unmapped windows should be placed in IconicState, according to 
the ICCCM. Windows which are actually iconified or minimized 
should have the _NET_WM_STATE_HIDDEN property set, to 
communicate to pagers that the window should not be represented as 
"onscreen."
</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2688204"></a>Pagers</h3></div></div></div><p>A pager offers a different UI for window management tasks.  It shows a 
miniature view of the desktop(s) representing managed windows by small 
rectangles and allows the user to initiate various window manager actions by manipulating 
these representations.  Typically offered actions are activation (see <a class="xref" href="#activation" title="Activation">the section called &#8220;Activation&#8221;</a>), 
moving, restacking, iconification, maximization and closing.  On a large 
desktop, the pager may offer a way to move the viewport.  On virtual desktops, 
the pager may offer ways to move windows between desktops and to change the 
current desktop.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2682511"></a>Taskbars</h3></div></div></div><p>A taskbar offers another UI for window management tasks.  It typically 
represents client windows as a list of buttons labelled with the window
titles and possibly icons.  Pressing a button initiates a window manager action on the
represented window, typical actions being activation and iconification. 
In environments with a taskbar, icons are often considered inappropriate,
since the iconified windows are already represented in the taskbar.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activation"></a>Activation</h3></div></div></div><p>In the X world, activating a window means to give it the input focus.
This may not be possible if the window is unmapped, because it is on a
different desktop.  Thus, activating a window may involve additional steps
like moving it to the current desktop (or changing to the desktop the window
is on), deiconifying it or raising it.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2682546"></a>Animated iconification</h3></div></div></div><p>Some window managers display some form of animation when (de-)iconifying a window.
This may be a line drawing connecting the corners of the window with
the corners of the icon or the window may be opaquely moved and resized 
on some trajectory joining the window location and the icon location.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2682561"></a>Window-in-window MDI</h3></div></div></div><p>Window-in-window MDI is a multiple document interface known from MS
Windows platforms. Programs employing it have a single top-level window
which contains a workspace which contains the subwindows for the open
documents. These subwindows are decorated with window manager frames and can be
manipulated within their parent window just like ordinary top-level
windows on the root window.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2682577"></a>Layered stacking order</h3></div></div></div><p>
Some window managers keep the toplevel windows not in a single linear stack,
but subdivide the stack into several layers.  There is a lot of variation 
among the features of layered stacking order implementations. The number of
layers may or may not be fixed. The layer of a toplevel window may be explicit
and directly modifiable or derived from other properties of the window, e.g. 
the <span class="emphasis"><em>type</em></span> of the window. The stacking order may or may not
be strict, i.e. not allow the user to raise or lower windows beyond their 
layer.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2682599"></a>Scope of this spec</h3></div></div></div><p>This spec tries to address the following issues:</p><div class="itemizedlist"><ul type="disc"><li><p>Allow clients to influence their initial state with respect 
to maximization, shading, stickiness, desktop, stacking order.</p></li><li><p>Improve the window managers ability to vary window 
decorations and maintain the stacking order by allowing clients to hint the 
window manager about the type of their windows.</p></li><li><p>Enable pagers and taskbars to be implemented as separate 
clients and allow them to work with any compliant window manager.</p></li></ul></div><p>This spec doesn't cover any of the following:</p><div class="itemizedlist"><ul type="disc"><li><p>Other IPC mechanisms like ICE or Corba.</p></li><li><p>Window manager configuration.</p></li><li><p>Window manager documentation.</p></li><li><p>Clients appearing on a proper subset of desktops.</p></li><li><p>Window-in-window MDI.</p></li></ul></div><p>The window manager is supposed to be in charge of window management 
policy, so that there is consistent behavior on the user's screen no matter 
who wrote the clients.</p><p>The spec offers a lot of external control about window manager actions.  
This is intended mainly to allow pagers, taskbars and similar window manager 
UIs to be implemented as separate clients.  "Ordinary" clients shouldn't use 
these except maybe in response to a direct user request (i.e. setting a 
config option to start maximized or specifying a -desk n command line 
argument).</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2687642"></a>Root Window Properties (and Related Messages)</h2></div></div></div><p>
Whenever this spec speaks about &#8220;<span class="quote">sending a message to the root 
window</span>&#8221;, it is understood that the client is supposed to create 
a ClientMessage event with the specified contents and send it by using 
a SendEvent request with the following arguments:
	</p><pre class="programlisting">
destination     root
propagate       False
event-mask      (SubstructureNotify|SubstructureRedirect)
event           the specified ClientMessage
</pre><p>
	</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2687662"></a>_NET_SUPPORTED</h3></div></div></div><pre class="programlisting">
_NET_SUPPORTED, ATOM[]/32
</pre><p>
This property MUST be set by the Window Manager to indicate which hints it
supports.  For example: considering _NET_WM_STATE 
both this atom and all supported states e.g. _NET_WM_STATE_MODAL, 
_NET_WM_STATE_STICKY, would be listed. This assumes that backwards 
incompatible changes will not be made to the hints (without being renamed). 
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2687686"></a>_NET_CLIENT_LIST</h3></div></div></div><pre class="programlisting">
_NET_CLIENT_LIST, WINDOW[]/32
_NET_CLIENT_LIST_STACKING, WINDOW[]/32
</pre><p>
These arrays contain all X Windows managed by the Window Manager.  
_NET_CLIENT_LIST has initial mapping order, starting with the oldest window. 
_NET_CLIENT_LIST_STACKING has bottom-to-top stacking order.  These properties
SHOULD be set and updated by the Window Manager.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2687708"></a>_NET_NUMBER_OF_DESKTOPS</h3></div></div></div><pre class="programlisting">
_NET_NUMBER_OF_DESKTOPS, CARDINAL/32
</pre><p>
This property SHOULD be set and updated by the Window Manager to indicate the
number of virtual desktops. 
	</p><p>
A Pager can request a change in the number of desktops by sending a _NET_NUMBER_OF_DESKTOPS message to the root window:
	</p><pre class="programlisting">
_NET_NUMBER_OF_DESKTOPS
  message_type = _NET_NUMBER_OF_DESKTOPS
  format = 32
  data.l[0] = new_number_of_desktops
  other data.l[] elements = 0
</pre><p>
The Window Manager is free to honor or reject this request. If the request is honored _NET_NUMBER_OF_DESKTOPS MUST be set to the new number of desktops, _NET_VIRTUAL_ROOTS MUST be set to store the new number of desktop virtual root window IDs and _NET_DESKTOP_VIEWPORT and _NET_WORKAREA must also be changed accordingly. The _NET_DESKTOP_NAMES property MAY remain unchanged.
	</p><p> 
If the number of desktops is shrinking and _NET_CURRENT_DESKTOP is out of the new range of available desktops, then this MUST be set to the last available desktop from the new set.  Clients that are still present on desktops that are out of the new range MUST be moved to the very last desktop from the new set. For these _NET_WM_DESKTOP MUST be updated.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2687765"></a>_NET_DESKTOP_GEOMETRY</h3></div></div></div><pre class="programlisting">
_NET_DESKTOP_GEOMETRY width, height, CARDINAL[2]/32
</pre><p>
	Array of two cardinals that defines the common size of all desktops
	(this is equal to the screen size if the Window Manager doesn't support
	large desktops, otherwise it's equal to the virtual size of the
	desktop). This property SHOULD be set by the Window Manager. 
		</p><p>
A Pager can request a change in the desktop geometry by sending a _NET_DESKTOP_GEOMETRY client
message to the root window:
		</p><pre class="programlisting">
_NET_DESKTOP_GEOMETRY
  message_type = _NET_DESKTOP_GEOMETRY 
  format = 32
  data.l[0] = new_width
  data.l[1] = new_height
  other data.l[] elements = 0
</pre><p>
The Window Manager MAY choose to ignore this message, in which case _NET_DESKTOP_GEOMETRY property will remain unchanged.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2687806"></a>_NET_DESKTOP_VIEWPORT</h3></div></div></div><pre class="programlisting">
_NET_DESKTOP_VIEWPORT x, y, CARDINAL[][2]/32
</pre><p>
Array of pairs of cardinals that define the top left corner of each desktop's 
viewport.  For Window Managers that don't support large desktops, this MUST 
always be set to (0,0).  
	</p><p>
A Pager can request to change the viewport for the current desktop by sending a
_NET_DESKTOP_VIEWPORT client message to the root window:
	</p><pre class="programlisting">
_NET_DESKTOP_VIEWPORT
  message_type = _NET_DESKTOP_VIEWPORT
  format = 32
  data.l[0] = new_vx
  data.l[1] = new_vy
  other data.l[] elements = 0
</pre><p>
The Window Manager MAY choose to ignore this message, in which case _NET_DESKTOP_VIEWPORT property will remain unchanged.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2687845"></a>_NET_CURRENT_DESKTOP</h3></div></div></div><pre class="programlisting">
_NET_CURRENT_DESKTOP desktop, CARDINAL/32
</pre><p>
The index of the current desktop. This is always an integer between 0 and 
_NET_NUMBER_OF_DESKTOPS - 1. This MUST be set and updated by the Window 
Manager.  If a Pager wants to switch to another virtual desktop, it MUST send 
a _NET_CURRENT_DESKTOP client message to the root window:
	</p><pre class="programlisting">
_NET_CURRENT_DESKTOP
  message_type = _NET_CURRENT_DESKTOP 
  format = 32
  data.l[0] = new_index
  data.l[1] = timestamp
  other data.l[] elements = 0
</pre><p>
Note that the timestamp may be 0 for clients using an older version of
this spec, in which case the timestamp field should be ignored.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731041"></a>_NET_DESKTOP_NAMES</h3></div></div></div><pre class="programlisting">
_NET_DESKTOP_NAMES, UTF8_STRING[]
</pre><p>
The names of all virtual desktops. This is a list of NULL-terminated strings in
	UTF-8 encoding [<span class="citation"><a class="link" href="#UTF8">UTF8</a></span>]. This property MAY be
	changed by a Pager or the Window Manager at any time. 
	</p><p>
Note: The number of names could be different from _NET_NUMBER_OF_DESKTOPS.
If it is less than _NET_NUMBER_OF_DESKTOPS, then the desktops with high
numbers are unnamed. If it is larger than _NET_NUMBER_OF_DESKTOPS, then the 
excess names outside of the _NET_NUMBER_OF_DESKTOPS are considered to be
reserved in case the number of desktops is increased.
</p><p>
Rationale: The name is not a necessary attribute of a virtual desktop. Thus 
the availability or unavailability of names has no impact on virtual desktop
functionality. Since names are set by users and users are likely to preset 
names for a fixed number of desktops, it doesn't make sense to shrink or grow 
this list when the number of available desktops changes.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731082"></a>_NET_ACTIVE_WINDOW</h3></div></div></div><pre class="programlisting">
_NET_ACTIVE_WINDOW, WINDOW/32
</pre><p>
The window ID of the currently active window or None if no window has the focus.
This is a read-only property set by the
Window Manager.  If a Client wants to activate
another window, it MUST send a _NET_ACTIVE_WINDOW client message to the root
window: 
	</p><pre class="programlisting">
_NET_ACTIVE_WINDOW
  window  = window to activate
  message_type = _NET_ACTIVE_WINDOW
  format = 32
  data.l[0] = source indication 
  data.l[1] = timestamp
  data.l[2] = requestor's currently active window, 0 if none
  other data.l[] elements = 0
</pre><p>
Source indication should be 1 when the request comes from an application, and 2
when it comes from a pager. Clients using older version of this spec use 0
as source indication, see <a class="xref" href="#sourceindication" title="Source indication in requests">the section called &#8220;Source indication in requests&#8221;</a> for details.
The timestamp is Client's last user activity timestamp (see _NET_WM_USER_TIME)
at the time of the request, and the currently active window
is the Client's active toplevel window, if any (the Window Manager may
be e.g. more likely to obey the request if it will mean transferring
focus from one active window to another).
        </p><p>
Depending on the information provided with the message, the Window Manager may
decide to refuse the request (either completely ignore it, or e.g. use
_NET_WM_STATE_DEMANDS_ATTENTION).
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731133"></a>_NET_WORKAREA</h3></div></div></div><pre class="programlisting">
_NET_WORKAREA, x, y, width, height CARDINAL[][4]/32

	</pre><p>
This property MUST be set by the Window Manager upon calculating the work area for  
each desktop.  Contains a geometry for each desktop.  These geometries are 
specified relative to the viewport on each desktop and specify an area that is
completely contained within the viewport.
 Work area SHOULD be used by desktop applications to place desktop icons appropriately.
	</p><p>
The Window Manager SHOULD calculate this space by taking the current
page minus space occupied by dock and panel windows, as indicated by
the <a class="link" href="#NETWMSTRUT">_NET_WM_STRUT</a> or <a class="link" href="#NETWMSTRUTPARTIAL">_NET_WM_STRUT_PARTIAL</a> properties set on
client windows.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731172"></a>_NET_SUPPORTING_WM_CHECK</h3></div></div></div><pre class="programlisting">
_NET_SUPPORTING_WM_CHECK, WINDOW/32
</pre><p>
The Window Manager MUST set this property on the root window to be the ID of a
	child window created by himself, to indicate that a compliant window manager is
	active.  The child window MUST also have the _NET_SUPPORTING_WM_CHECK
	property set to the ID of the child window. The child window MUST also
	have the _NET_WM_NAME property set to the name of the Window Manager.
	</p><p>
Rationale:  The child window is used to distinguish an active Window Manager 
 from a stale _NET_SUPPORTING_WM_CHECK 
 property that happens to point to another window. If the
 _NET_SUPPORTING_WM_CHECK window on the client window is missing
 or not properly set, clients SHOULD assume that no conforming
 Window Manager is present.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731204"></a>_NET_VIRTUAL_ROOTS</h3></div></div></div><pre class="programlisting">
_NET_VIRTUAL_ROOTS, WINDOW[]/32
</pre><p>
To implement virtual desktops, some Window Managers reparent client windows to 
a child of the root window.  Window Managers using this technique MUST set 
this property to a list of IDs for windows that are acting as virtual root 
windows.  This property allows background setting programs to work with 
virtual roots and allows clients to figure out the window manager frame windows of their 
windows.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731226"></a>_NET_DESKTOP_LAYOUT</h3></div></div></div><pre class="programlisting">
_NET_DESKTOP_LAYOUT, orientation, columns, rows, starting_corner CARDINAL[4]/32

  #define _NET_WM_ORIENTATION_HORZ 0
  #define _NET_WM_ORIENTATION_VERT 1

  #define _NET_WM_TOPLEFT     0
  #define _NET_WM_TOPRIGHT    1
  #define _NET_WM_BOTTOMRIGHT 2
  #define _NET_WM_BOTTOMLEFT  3
</pre><p>
        <span class="emphasis"><em>This property is set by a Pager, not by the Window 
	  Manager.</em></span>
        When setting this property, the Pager must own a manager selection (as
	defined in the ICCCM 2.8). The manager selection is called
        _NET_DESKTOP_LAYOUT_S<code class="literal">n</code> where
        <code class="literal">n</code> is the screen number. The purpose of 
        this property is to allow the Window Manager to know the desktop 
        layout displayed by the Pager.
        </p><p>
  _NET_DESKTOP_LAYOUT describes the layout of virtual
  desktops relative to each other. More specifically, it describes the layout
  used by the owner of the manager selection. The Window Manager may use 
  this layout information or may choose to ignore it.
  The property contains four values: the Pager orientation, the number of
  desktops in the X direction, the number in the Y direction, and the
  starting corner of the layout, i.e. the corner containing the first desktop.
        </p><p>
   Note: In order to inter-operate with Pagers implementing an earlier
   draft of this document, Window Managers should accept a
  _NET_DESKTOP_LAYOUT property of length 3 and
  use _NET_WM_TOPLEFT as the starting corner in this case.
  </p><p>
  The virtual desktops are arranged in a rectangle with 
  <code class="literal">rows</code> rows and <code class="literal">columns</code> columns.
  If <code class="literal">rows</code> times <code class="literal">columns</code> does not match 
  the total number of desktops as specified by
  _NET_NUMBER_OF_DESKTOPS, the highest-numbered
  workspaces are assumed to be nonexistent. Either <code class="literal">rows</code> or 
  <code class="literal">columns</code> (but not both) may be specified as 0 in which 
  case its actual value will be derived from _NET_NUMBER_OF_DESKTOPS.
        </p><p>
  When the orientation is _NET_WM_ORIENTATION_HORZ
  the desktops are laid out in rows, with the first desktop in the 
  specified starting corner. So a layout with four columns and three rows 
  starting in the _NET_WM_TOPLEFT corner looks like this:
</p><pre class="programlisting">
 +--+--+--+--+
 | 0| 1| 2| 3|
 +--+--+--+--+
 | 4| 5| 6| 7|
 +--+--+--+--+
 | 8| 9|10|11|
 +--+--+--+--+
</pre><p>
With starting_corner _NET_WM_BOTTOMRIGHT, it looks like this:
</p><pre class="programlisting">
 +--+--+--+--+
 |11|10| 9| 8|
 +--+--+--+--+
 | 7| 6| 5| 4|
 +--+--+--+--+
 | 3| 2| 1| 0|
 +--+--+--+--+
</pre><p>

         </p><p>
  When the orientation is _NET_WM_ORIENTATION_VERT
  the layout with four columns and three rows starting in the _NET_WM_TOPLEFT
  corner looks like:

</p><pre class="programlisting">
 +--+--+--+--+
 | 0| 3| 6| 9|
 +--+--+--+--+
 | 1| 4| 7|10|
 +--+--+--+--+
 | 2| 5| 8|11|
 +--+--+--+--+
</pre><p>
With starting_corner _NET_WM_TOPRIGHT, it looks like:

</p><pre class="programlisting">
 +--+--+--+--+
 | 9| 6| 3| 0|
 +--+--+--+--+
 |10| 7| 4| 1|
 +--+--+--+--+
 |11| 8| 5| 2|
 +--+--+--+--+
</pre><p>
       </p><p>
         The numbers here are the desktop numbers, as for 
         _NET_CURRENT_DESKTOP.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731380"></a>_NET_SHOWING_DESKTOP</h3></div></div></div><pre class="programlisting">
_NET_SHOWING_DESKTOP desktop, CARDINAL/32
</pre><p>
	Some Window Managers have a "showing the desktop" mode in which windows
	are hidden, and the desktop background is displayed and focused. If a
	Window Manager supports the _NET_SHOWING_DESKTOP hint, it MUST set it
	to a value of 1 when the Window Manager is in "showing the desktop" mode,
	and a value of zero if the Window Manager is not in this mode.
        </p><p>
	If a Pager wants to enter or leave the mode, it MUST
	send a _NET_SHOWING_DESKTOP client message to the root window
	requesting the change: 
       </p><pre class="programlisting">
_NET_SHOWING_DESKTOP
  message_type = _NET_SHOWING_DESKTOP 
  format = 32
  data.l[0] = boolean 0 or 1
  other data.l[] elements = 0
</pre><p> 
 The Window Manager may choose to ignore this client message.
       </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2731418"></a>Other Root Window Messages</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731423"></a>_NET_CLOSE_WINDOW</h3></div></div></div><pre class="programlisting">
_NET_CLOSE_WINDOW
</pre><p>
	Pagers wanting to close a window MUST send a _NET_CLOSE_WINDOW client
	message request to the root window:
	</p><pre class="programlisting">
_NET_CLOSE_WINDOW
  window = window to close
  message_type = _NET_CLOSE_WINDOW
  format = 32
  data.l[0] = timestamp
  data.l[1] = source indication
  other data.l[] elements = 0
</pre><p>
The Window Manager MUST then attempt to close the window specified.
See <a class="xref" href="#sourceindication" title="Source indication in requests">the section called &#8220;Source indication in requests&#8221;</a> for details on the source indication.
	</p><p>
	Rationale: A Window Manager might be more clever than the usual method (send WM_DELETE message if the protocol is selected, XKillClient otherwise).  It might introduce a timeout, for example.  Instead of duplicating the code, the Window Manager can easily do the job.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731465"></a>_NET_MOVERESIZE_WINDOW</h3></div></div></div><pre class="programlisting">
_NET_MOVERESIZE_WINDOW
  window = window to be moved or resized
  message_type = _NET_MOVERESIZE_WINDOW
  format = 32
  data.l[0] = gravity and flags 
  data.l[1] = x 
  data.l[2] = y
  data.l[3] = width
  data.l[4] = height
</pre><p>
        The low byte of data.l[0] contains the gravity to use; it may contain 
	any value allowed for the WM_SIZE_HINTS.win_gravity property:
	NorthWest (1), North (2), NorthEast (3), West (4), Center (5), East
	(6), SouthWest (7), South (8), SouthEast (9) and Static (10). A 
	gravity of 0 indicates that the Window Manager should use the gravity
	specified in WM_SIZE_HINTS.win_gravity. The bits 8 to 11 indicate the
	presence of x, y, width and height. The bits 12 to 15 indicate the 
	source (see <a class="xref" href="#sourceindication" title="Source indication in requests">the section called &#8220;Source indication in requests&#8221;</a>), so 0001 indicates
	the application and 0010 indicates a Pager or a Taskbar.
	The remaining bits should be set to zero.
        </p><p>
	Pagers wanting to move or resize a window may send a
	_NET_MOVERESIZE_WINDOW client message request to the root window
	instead of using a ConfigureRequest. 
	</p><p>
	Window Managers should treat a _NET_MOVERESIZE_WINDOW message exactly 
	like a ConfigureRequest (in particular, adhering to the ICCCM rules
	about synthetic ConfigureNotify events), except that they should use
	the gravity specified in the message. 
        </p><p>
	Rationale: Using a _NET_MOVERESIZE_WINDOW message with StaticGravity
	allows Pagers to exactly position and resize a window including its 
	decorations without knowing the size of the decorations.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731519"></a>_NET_WM_MOVERESIZE</h3></div></div></div><pre class="programlisting">
_NET_WM_MOVERESIZE
  window = window to be moved or resized
  message_type = _NET_WM_MOVERESIZE
  format = 32
  data.l[0] = x_root 
  data.l[1] = y_root
  data.l[2] = direction
  data.l[3] = button
  data.l[4] = source indication
</pre><p>
	This message allows Clients to initiate window movement or 
        resizing.  They can define their own move and size
	"grips", whilst letting the Window Manager control the actual operation.
	This means that all moves/resizes can happen in a consistent manner as 
	defined by the Window Manager. See <a class="xref" href="#sourceindication" title="Source indication in requests">the section called &#8220;Source indication in requests&#8221;</a>
	for details on the source indication.
	</p><p>
	When sending this message in response to a button press event, button 
	SHOULD indicate the button which was pressed, x_root and y_root MUST 
	indicate the position of the button press with respect to the root 
	window and direction MUST indicate whether this is a move or resize 
	event, and if it is a resize event, which edges of the window the size 
	grip applies to. When sending this message in response to a key event, 
	the direction MUST indicate whether this this is a move or resize
	event and the other fields are unused. 
	</p><pre class="programlisting">
#define _NET_WM_MOVERESIZE_SIZE_TOPLEFT      0
#define _NET_WM_MOVERESIZE_SIZE_TOP          1
#define _NET_WM_MOVERESIZE_SIZE_TOPRIGHT     2
#define _NET_WM_MOVERESIZE_SIZE_RIGHT        3
#define _NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT  4
#define _NET_WM_MOVERESIZE_SIZE_BOTTOM       5
#define _NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT   6
#define _NET_WM_MOVERESIZE_SIZE_LEFT         7
#define _NET_WM_MOVERESIZE_MOVE              8   /* movement only */
#define _NET_WM_MOVERESIZE_SIZE_KEYBOARD     9   /* size via keyboard */
#define _NET_WM_MOVERESIZE_MOVE_KEYBOARD    10   /* move via keyboard */
</pre><p>
	The Client MUST release all grabs prior to sending such message.
	</p><p>
        The Window Manager can use the button field to determine the
	events on which it terminates the operation initiated by the
        _NET_WM_MOVERESIZE message. Since there is a race condition between 
	a client sending the _NET_WM_MOVERESIZE message and the user releasing 
	the button, Window Managers are advised to offer some other means to 
	terminate the operation, e.g. by pressing the ESC key.  
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731571"></a>_NET_RESTACK_WINDOW</h3></div></div></div><pre class="programlisting">
_NET_RESTACK_WINDOW
</pre><p>
	Pagers wanting to restack a window SHOULD send a _NET_RESTACK_WINDOW client
	message request to the root window:
	</p><pre class="programlisting">
_NET_RESTACK_WINDOW
  window = window to restack
  message_type = _NET_RESTACK_WINDOW
  format = 32
  data.l[0] = source indication
  data.l[1] = sibling window
  data.l[2] = detail
  other data.l[] elements = 0
</pre><p>
        This request is similar to ConfigureRequest with CWSibling and CWStackMode flags. It should be used only by pagers,
        applications can use normal ConfigureRequests. The source indication field should be therefore set to 2,
        see <a class="xref" href="#sourceindication" title="Source indication in requests">the section called &#8220;Source indication in requests&#8221;</a> for details.
	</p><p>
	Rationale: A Window Manager may put restrictions on configure requests from applications, for example it may
        under some conditions refuse to raise a window. This request makes it clear it comes from a pager or similar
        tool, and therefore the Window Manager should always obey it.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731636"></a>_NET_REQUEST_FRAME_EXTENTS</h3></div></div></div><pre class="programlisting">
_NET_REQUEST_FRAME_EXTENTS
  window = window for which to set _NET_FRAME_EXTENTS
  message_type = _NET_REQUEST_FRAME_EXTENTS
</pre><p>
A Client whose window has not yet been mapped can request of the
Window Manager an estimate of the frame extents it will be given upon
mapping.  To retrieve such an estimate, the Client MUST send a
_NET_REQUEST_FRAME_EXTENTS message to the root window.  The Window
Manager MUST respond by estimating the prospective frame extents and
setting the window's _NET_FRAME_EXTENTS property accordingly.  The
Client MUST handle the resulting _NET_FRAME_EXTENTS PropertyNotify
event.  So that the Window Manager has a good basis for estimation,
the Client MUST set any window properties it intends to set
<span class="emphasis"><em>before</em></span> sending this message.  The Client MUST be able to cope
with imperfect estimates.
	</p><p>
Rationale: A client cannot calculate the dimensions of its window's
frame before the window is mapped, but some toolkits need this
information.  Asking the window manager for an estimate of the extents
is a workable solution.  The estimate may depend on the current theme,
font sizes or other window properties.  The client can track changes
to the frame's dimensions by listening for _NET_FRAME_EXTENTS
PropertyNotify events.
	</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2731686"></a>Application Window Properties</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731691"></a>_NET_WM_NAME</h3></div></div></div><pre class="programlisting">
_NET_WM_NAME, UTF8_STRING
</pre><p>
The Client SHOULD set this to the title of the window in UTF-8 encoding.  If
set, the Window Manager should use this in preference to WM_NAME.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731708"></a>_NET_WM_VISIBLE_NAME</h3></div></div></div><pre class="programlisting">
_NET_WM_VISIBLE_NAME, UTF8_STRING
</pre><p>
If the Window Manager displays a window name other than _NET_WM_NAME the Window Manager MUST set this to the title displayed in UTF-8 encoding.
	</p><p>
Rationale: This property is for Window Managers that display a title different from the _NET_WM_NAME or WM_NAME of the window (i.e. xterm &lt;1&gt;, xterm &lt;2&gt;, ... is shown, but _NET_WM_NAME / WM_NAME is still xterm for each window) thereby allowing Pagers to display the same title as the Window Manager.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731743"></a>_NET_WM_ICON_NAME</h3></div></div></div><pre class="programlisting">
_NET_WM_ICON_NAME, UTF8_STRING
</pre><p>
The Client SHOULD set this to the title of the icon for this window in UTF-8 
encoding.  If set, the Window Manager should use this in preference to 
WM_ICON_NAME.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731760"></a>_NET_WM_VISIBLE_ICON_NAME</h3></div></div></div><pre class="programlisting">
_NET_WM_VISIBLE_ICON_NAME, UTF8_STRING
</pre><p>
If the Window Manager displays an icon name other than _NET_WM_ICON_NAME 
the Window Manager MUST set this to the title displayed in UTF-8 encoding.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731778"></a>_NET_WM_DESKTOP</h3></div></div></div><pre class="programlisting">
_NET_WM_DESKTOP desktop, CARDINAL/32
</pre><p>
Cardinal to determine the desktop the window is in (or wants to be) starting
with 0 for the first desktop.  A Client MAY choose not to set this property,
in which case the Window Manager SHOULD place it as it wishes.  0xFFFFFFFF
indicates that the window SHOULD appear on all desktops.  
	</p><p>
The Window Manager should honor _NET_WM_DESKTOP whenever a withdrawn window
requests to be mapped.
        </p><p>
The Window Manager should remove the property whenever
a window is withdrawn but it should leave the property in place when it is
shutting down, e.g. in response to losing ownership of the WM_Sn manager 
selection.
	</p><p>
Rationale: Removing the property upon window withdrawal helps legacy 
applications which want to reuse withdrawn windows. Not removing the property
upon shutdown allows the next Window Manager to restore windows to their 
previous desktops. 
        </p><p>
A Client can request a change of desktop for a non-withdrawn window by sending
a _NET_WM_DESKTOP client message to the root window:
	</p><pre class="programlisting">
_NET_WM_DESKTOP
  window  = the respective client window
  message_type = _NET_WM_DESKTOP
  format = 32
  data.l[0] = new_desktop
  data.l[1] = source indication
  other data.l[] elements = 0
</pre><p>
	See <a class="xref" href="#sourceindication" title="Source indication in requests">the section called &#8220;Source indication in requests&#8221;</a> for details on the source
	indication.
	The Window Manager MUST keep this property updated on all windows.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731840"></a>_NET_WM_WINDOW_TYPE</h3></div></div></div><pre class="programlisting">
_NET_WM_WINDOW_TYPE, ATOM[]/32
</pre><p>
This SHOULD be set by the Client before mapping to a list of atoms indicating
the functional type of the window.  This property SHOULD be used by the window
manager in determining the decoration, stacking position and other behavior
of the window.  The Client SHOULD specify window types in order of preference
(the first being most preferable) but MUST include at least one of the basic
window type atoms from the list below.  This is to allow for extension of the
list of types whilst providing default behavior for Window Managers that do
not recognize the extensions.  
	</p><p>
Rationale:  This hint is intended to replace the MOTIF hints.  One of the
objections to the MOTIF hints is that they are a purely visual description of
the window decoration.  By describing the function of the window, the Window
Manager can apply consistent decoration and behavior to windows of the same
type.  Possible examples of behavior include keeping dock/panels on top or
allowing pinnable menus / toolbars to only be hidden when another window has
focus (NextStep style).  
	</p><pre class="programlisting">
_NET_WM_WINDOW_TYPE_DESKTOP, ATOM
_NET_WM_WINDOW_TYPE_DOCK, ATOM
_NET_WM_WINDOW_TYPE_TOOLBAR, ATOM
_NET_WM_WINDOW_TYPE_MENU, ATOM
_NET_WM_WINDOW_TYPE_UTILITY, ATOM
_NET_WM_WINDOW_TYPE_SPLASH, ATOM
_NET_WM_WINDOW_TYPE_DIALOG, ATOM
_NET_WM_WINDOW_TYPE_NORMAL, ATOM
</pre><p>
_NET_WM_WINDOW_TYPE_DESKTOP indicates a desktop feature.  This can include a
single window containing desktop icons with the same dimensions as the screen,
allowing the desktop environment to have full control of the desktop, without
the need for proxying root window clicks.  
	</p><p>
_NET_WM_WINDOW_TYPE_DOCK indicates a dock or panel feature.  Typically a
Window Manager would keep such windows on top of all other windows.  
	</p><p>
_NET_WM_WINDOW_TYPE_TOOLBAR and _NET_WM_WINDOW_TYPE_MENU indicate toolbar and
pinnable menu windows, respectively (i.e. toolbars and menus "torn off" from 
the main application). Windows of this type may set the WM_TRANSIENT_FOR 
hint indicating the main application window.
	</p><p>
_NET_WM_WINDOW_TYPE_UTILITY indicates a small persistent utility window, such as
a palette or toolbox. It is distinct from type TOOLBAR because it does not
correspond to a toolbar torn off from the main application. It's distinct from
type DIALOG because it isn't a transient dialog, the user will probably keep it
open while they're working. Windows of this type may set the WM_TRANSIENT_FOR
hint indicating the main application window.
	</p><p>
_NET_WM_WINDOW_TYPE_SPLASH indicates that the window is a splash screen
displayed as an application is starting up.
	</p><p>
_NET_WM_WINDOW_TYPE_DIALOG indicates that this is a dialog window.  If
_NET_WM_WINDOW_TYPE is not set, then windows with WM_TRANSIENT_FOR set MUST
be taken as this type.  
	</p><p>
_NET_WM_WINDOW_TYPE_NORMAL indicates that this is a normal, top-level window.
Windows with neither _NET_WM_WINDOW_TYPE nor WM_TRANSIENT_FOR set MUST
be taken as this type.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2731936"></a>_NET_WM_STATE</h3></div></div></div><pre class="programlisting">
_NET_WM_STATE, ATOM[]
</pre><p>
A list of hints describing the window state. Atoms present in the list MUST be
considered set, atoms not present in the list MUST be considered not set. The
Window Manager SHOULD honor
_NET_WM_STATE whenever a withdrawn window requests to be mapped.  A Client
wishing to change the state of a window MUST send a _NET_WM_STATE client
message to the root window (see below).  The Window Manager MUST keep this
property updated to reflect the current state of the window.
		</p><p>
The Window Manager should remove the property whenever
a window is withdrawn, but it should leave the property in place when it is
shutting down, e.g. in response to losing ownership of the WM_Sn manager 
selection.
	</p><p>
Rationale: Removing the property upon window withdrawal helps legacy 
applications which want to reuse withdrawn windows. Not removing the property
upon shutdown allows the next Window Manager to restore windows to their 
previous state. 
        </p><p>
Possible atoms are:
		</p><pre class="programlisting">
_NET_WM_STATE_MODAL, ATOM
_NET_WM_STATE_STICKY, ATOM
_NET_WM_STATE_MAXIMIZED_VERT, ATOM
_NET_WM_STATE_MAXIMIZED_HORZ, ATOM
_NET_WM_STATE_SHADED, ATOM
_NET_WM_STATE_SKIP_TASKBAR, ATOM
_NET_WM_STATE_SKIP_PAGER, ATOM
_NET_WM_STATE_HIDDEN, ATOM
_NET_WM_STATE_FULLSCREEN, ATOM
_NET_WM_STATE_ABOVE, ATOM
_NET_WM_STATE_BELOW, ATOM
_NET_WM_STATE_DEMANDS_ATTENTION, ATOM
</pre><p>
An implementation MAY add new atoms to this list. Implementations
without extensions MUST ignore any unknown atoms, effectively removing
them from the list. These extension atoms MUST NOT start with the prefix
_NET. 
      </p><p>
_NET_WM_STATE_MODAL indicates that this is a modal dialog box.  
If the WM_TRANSIENT_FOR hint is set to another toplevel window, the 
dialog is modal for that window; if WM_TRANSIENT_FOR is not set or set
to the root window the dialog is modal for its window group.
	</p><p>
_NET_WM_STATE_STICKY indicates that the Window Manager SHOULD keep the
window's position fixed on the screen, even when the virtual desktop scrolls.
	</p><p>
_NET_WM_STATE_MAXIMIZED_{VERT,HORZ} indicates that the window is
{vertically,horizontally} maximized.
	</p><p>
_NET_WM_STATE_SHADED indicates that the window is shaded.
	</p><p>
_NET_WM_STATE_SKIP_TASKBAR indicates that the window should not be
included on a taskbar. This hint should be requested by the
application, i.e. it indicates that the window by nature is never
in the taskbar.  Applications should not set this hint if
_NET_WM_WINDOW_TYPE already conveys the exact nature of the
window.
	</p><p>
_NET_WM_STATE_SKIP_PAGER indicates that the window should not be
included on a Pager. This hint should be requested by the application,
i.e. it indicates that the window by nature is never in the
Pager. Applications should not set this hint if _NET_WM_WINDOW_TYPE
already conveys the exact nature of the window.
	</p><p>
_NET_WM_STATE_HIDDEN should be set by the Window Manager to indicate
that a window would not be visible on the screen if its
desktop/viewport were active and its coordinates were within the
screen bounds. The canonical example is that minimized windows should
be in the _NET_WM_STATE_HIDDEN state.  Pagers and similar applications
should use _NET_WM_STATE_HIDDEN instead of WM_STATE to decide whether
to display a window in miniature representations of the windows on a
desktop.
        </p><p>
Implementation note: if an Application asks to toggle
_NET_WM_STATE_HIDDEN the Window Manager should probably just ignore
the request, since _NET_WM_STATE_HIDDEN is a function of some other
aspect of the window such as minimization, rather than an independent
state.
</p><p>
_NET_WM_STATE_FULLSCREEN indicates that the window should fill the entire
	screen and have no window decorations. Additionally the Window
	Manager is responsible for restoring the original geometry after a
	switch from fullscreen back to normal window. For example, a
	presentation program would use this hint.
	</p><p>
_NET_WM_STATE_ABOVE indicates that the window should be on top of most 
windows (see <a class="xref" href="#STACKINGORDER" title="Stacking order">the section called &#8220;Stacking order&#8221;</a> for details). 
        </p><p>
_NET_WM_STATE_BELOW indicates that the window should be below most 
windows (see <a class="xref" href="#STACKINGORDER" title="Stacking order">the section called &#8220;Stacking order&#8221;</a> for details). 
       </p><p>
	_NET_WM_STATE_ABOVE and _NET_WM_STATE_BELOW are mainly meant for user
	preferences and should not be used by applications e.g. for drawing 
	attention to their dialogs (the Urgency
	hint should be used in that case, see <a class="xref" href="#URGENCY" title="Urgency">the section called &#8220;Urgency&#8221;</a>).' 
       </p><p>
_NET_WM_STATE_DEMANDS_ATTENTION indicates that some action in or with the window
happened. For example, it may be set by the Window Manager if the window requested
activation but the Window Manager refused it, or the application may set it if it
finished some work. This state may be set by both the Client and
the Window Manager. It should be unset by the Window Manager when it decides
the window got the required attention (usually, that it got activated).
	</p><p>
To change the state of a mapped window, a Client MUST send a _NET_WM_STATE
client message to the root window:
	</p><pre class="programlisting">
  window  = the respective client window
  message_type = _NET_WM_STATE
  format = 32
  data.l[0] = the action, as listed below
  data.l[1] = first property to alter
  data.l[2] = second property to alter
  data.l[3] = source indication
  other data.l[] elements = 0
</pre><p>
This message allows two properties to be changed simultaneously, specifically
to allow both horizontal and vertical maximization to be altered together.
l[2] MUST be set to zero if only one property is to be changed.
See <a class="xref" href="#sourceindication" title="Source indication in requests">the section called &#8220;Source indication in requests&#8221;</a> for details on the source indication.
l[0], the action, MUST be one of:
	</p><pre class="programlisting">
_NET_WM_STATE_REMOVE        0    /* remove/unset property */
_NET_WM_STATE_ADD           1    /* add/set property */
_NET_WM_STATE_TOGGLE        2    /* toggle property  */
</pre><p>
	See also the implementation notes on <a class="link" href="#URGENCY" title="Urgency">urgency</a> and <a class="link" href="#NORESIZE" title="Fixed size windows">fixed size windows</a>.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732155"></a>_NET_WM_ALLOWED_ACTIONS</h3></div></div></div><pre class="programlisting">
_NET_WM_ALLOWED_ACTIONS, ATOM[]
</pre><p>
A list of atoms indicating user operations that the Window Manager supports for
this window. Atoms present in the list indicate allowed actions, atoms not
present in the list indicate actions that are not supported for this window.
The Window Manager MUST keep this property updated to reflect the 
actions which are currently "active" or "sensitive" for a window.
Taskbars, Pagers, and other tools use _NET_WM_ALLOWED_ACTIONS to 
decide which actions should be made available to the user.
		</p><p>
Possible atoms are:
		</p><pre class="programlisting">
_NET_WM_ACTION_MOVE, ATOM
_NET_WM_ACTION_RESIZE, ATOM
_NET_WM_ACTION_MINIMIZE, ATOM
_NET_WM_ACTION_SHADE, ATOM
_NET_WM_ACTION_STICK, ATOM
_NET_WM_ACTION_MAXIMIZE_HORZ, ATOM
_NET_WM_ACTION_MAXIMIZE_VERT, ATOM
_NET_WM_ACTION_FULLSCREEN, ATOM
_NET_WM_ACTION_CHANGE_DESKTOP, ATOM
_NET_WM_ACTION_CLOSE, ATOM
</pre><p>
An implementation MAY add new atoms to this list. Implementations
without extensions MUST ignore any unknown atoms, effectively removing
them from the list. These extension atoms MUST NOT start with the prefix
_NET.
      </p><p>
Note that the actions listed here are those that the <span class="emphasis"><em>Window
Manager</em></span> will honor for this window. The operations must still be
requested through the normal mechanisms outlined in this specification. For
example, _NET_WM_ACTION_CLOSE does not mean that clients can send a
WM_DELETE_WINDOW message to this window; it means that clients can use a
_NET_CLOSE_WINDOW message to ask the Window Manager to do so.
       </p><p>
Window Managers SHOULD ignore the value of _NET_WM_ALLOWED_ACTIONS when they 
initially manage a window. This value may be left over from a previous Window 
Manager with different policies.
      </p><p>
_NET_WM_ACTION_MOVE indicates that the window may be moved around the screen.
	</p><p>
_NET_WM_ACTION_RESIZE indicates that the window may be resized.
(Implementation note: Window Managers can identify a non-resizable 
window because its minimum and maximum size in WM_NORMAL_HINTS will be the same.)
	</p><p>
_NET_WM_ACTION_MINIMIZE indicates that the window may be iconified.
	</p><p>
_NET_WM_ACTION_SHADE indicates that the window may be shaded.
	</p><p>
_NET_WM_ACTION_STICK indicates that the window may have its sticky state 
toggled (as for _NET_WM_STATE_STICKY). Note that this state has to do with 
viewports, not desktops.
	</p><p>
_NET_WM_ACTION_MAXIMIZE_HORZ indicates that the window may be maximized horizontally.
	</p><p>
_NET_WM_ACTION_MAXIMIZE_VERT indicates that the window may be maximized vertically.
	</p><p>
_NET_WM_ACTION_FULLSCREEN indicates that the window may be brought to
	fullscreen state.
	</p><p>
_NET_WM_ACTION_CHANGE_DESKTOP indicates that the window may be moved between desktops.
	</p><p>
_NET_WM_ACTION_CLOSE indicates that the window may be closed (i.e. a WM_DELETE_WINDOW 
message may be sent).
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732272"></a>_NET_WM_STRUT</h3></div></div></div><a name="NETWMSTRUT"></a><pre class="programlisting">
_NET_WM_STRUT, left, right, top, bottom, CARDINAL[4]/32
</pre><p>
This property is equivalent to a _NET_WM_STRUT_PARTIAL property where all start
values are 0 and all end values are the height or width of the logical screen.
_NET_WM_STRUT_PARTIAL was introduced later than _NET_WM_STRUT, however, so
clients MAY set this property in addition to _NET_WM_STRUT_PARTIAL to ensure
backward compatibility with Window Managers supporting older versions of the
Specification.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732296"></a>_NET_WM_STRUT_PARTIAL</h3></div></div></div><a name="NETWMSTRUTPARTIAL"></a><pre class="programlisting">
_NET_WM_STRUT_PARTIAL, left, right, top, bottom, left_start_y, left_end_y,
right_start_y, right_end_y, top_start_x, top_end_x, bottom_start_x,
bottom_end_x,CARDINAL[12]/32
</pre><p>
This property MUST be set by the Client if the window is to reserve space at the
edge of the screen.  The property contains 4 cardinals specifying the width of
the reserved area at each border of the screen, and an additional 8 cardinals
specifying the beginning and end corresponding to each of the four struts.  The
order of the values is left, right, top, bottom, left_start_y, left_end_y,
right_start_y, right_end_y, top_start_x, top_end_x, bottom_start_x,
bottom_end_x. All coordinates are root window coordinates. The client MAY change
this property at any time, therefore the Window Manager MUST watch for
property notify events if the Window Manager uses this property to assign
special semantics to the window.
	</p><p>
If both this property and the _NET_WM_STRUT property are set, the Window Manager
MUST ignore the _NET_WM_STRUT property values and use instead the values for
_NET_WM_STRUT_PARTIAL.  This will ensure that Clients can safely set both
properties without giving up the improved semantics of the new property.
	</p><p>
The purpose of struts is to reserve space at the borders of the
desktop.  This is very useful for a docking area, a taskbar or a panel,
for instance. The Window Manager should take this reserved area into
account when constraining window positions - maximized windows, for
example, should not cover that area.
	</p><p> 
The start and end values associated with each strut allow areas to be
reserved which do not span the entire width or height of the screen.
Struts MUST be specified in root window coordinates, that is, they are
<span class="emphasis"><em>not</em></span> relative to the edges of any view port or Xinerama
monitor.
	</p><p>
For example, for a panel-style Client appearing at the bottom of the
screen, 50 pixels tall, and occupying the space from 200-600 pixels
from the left of the screen edge would set a bottom strut of 50, and
set bottom_start_x to 200 and bottom_end_x to 600.  Another example is
a panel on a screen using the Xinerama extension.  Assume that the set
up uses two monitors, one running at 1280x1024 and the other to the
right running at 1024x768, with the top edge of the two physical
displays aligned.  If the panel wants to fill the entire bottom edge
of the smaller display with a panel 50 pixels tall, it should set a
bottom strut of 306, with bottom_start_x of 1280, and bottom_end_x of
2303.  Note that the strut is relative to the screen edge, and not the
edge of the xinerama monitor.
	</p><p>
Rationale: A simple "do not cover" hint is not enough for dealing with e.g.
auto-hide panels. 
	</p><p>
Notes: An auto-hide panel SHOULD set the strut to be its minimum, hidden size.
A "corner" panel that does not extend for the full length of a screen border
SHOULD only set one strut.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732383"></a>_NET_WM_ICON_GEOMETRY</h3></div></div></div><pre class="programlisting">
_NET_WM_ICON_GEOMETRY, x, y, width, height, CARDINAL[4]/32
</pre><p>
This optional property MAY be set by stand alone tools like a taskbar or an 
iconbox.  It specifies the geometry of a possible icon in case the window is iconified.
	</p><p>
Rationale: This makes it possible for a Window Manager to display a nice
animation like morphing the window into its icon.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732407"></a>_NET_WM_ICON</h3></div></div></div><pre class="programlisting">
_NET_WM_ICON CARDINAL[][2+n]/32
</pre><p>
This is an array of possible icons for the client.  This specification does
not stipulate what size these icons should be, but individual desktop
environments or toolkits may do so.  The Window Manager MAY scale any of these
icons to an appropriate size.
		</p><p>
This is an array of 32bit packed CARDINAL ARGB with high byte being A, low
byte being B.  The first two cardinals are width, height.  Data is in rows, left to
right and top to bottom.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732434"></a>_NET_WM_PID</h3></div></div></div><pre class="programlisting">
_NET_WM_PID CARDINAL/32
</pre><p>
If set, this property MUST contain the process ID of the client owning this
window.  This MAY be used by the Window Manager to kill windows which do not
respond to the _NET_WM_PING protocol.
		</p><p>
If _NET_WM_PID is set, the ICCCM-specified property WM_CLIENT_MACHINE
MUST also be set.  While the ICCCM only requests that WM_CLIENT_MACHINE is set
&#8220;<span class="quote"> to a string that forms the name of the machine running the client as
seen from the machine running the server</span>&#8221; conformance to this
specification requires that WM_CLIENT_MACHINE be set to the fully-qualified domain 
name of the client's host.
	</p><p>
See also the implementation notes on <a class="link" href="#KILLINGWINDOWS" title="Killing Hung Processes">killing hung processes</a>.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732475"></a>_NET_WM_HANDLED_ICONS</h3></div></div></div><pre class="programlisting">
_NET_WM_HANDLED_ICONS
</pre><p>
	This property can be set by a Pager on one of its own toplevel windows
	to indicate that the Window Manager need not provide icons for
	iconified windows, for example if it is a taskbar and provides buttons
	for iconified windows. 
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732493"></a>_NET_WM_USER_TIME</h3></div></div></div><pre class="programlisting">
_NET_WM_USER_TIME CARDINAL/32
</pre><p>
This property contains the XServer time at which last user activity in this
window took place.
        </p><p>
Clients should set this property on every new toplevel window, before mapping
the window, to the timestamp of the user interaction that caused the window to
appear.  A client that only deals with core events, might, for example, use the
timestamp of the last KeyPress or ButtonPress event. ButtonRelease and
KeyRelease events should not generally be considered to be user interaction,
because an application may receive KeyRelease events from global keybindings,
and generally release events may have later timestamp than actions that were
triggered by the matching press events.  Clients can obtain the timestamp that
caused its first window to appear from the DESKTOP_STARTUP_ID environment
variable, if the app was launched with startup notification.  If the client does
not know the timestamp of the user interaction that caused the first window to
appear (e.g. because it was not launched with startup notification), then it
should not set the property for that window.  The special value of zero on a
newly mapped window can be used to request that the window not be initially
focused when it is mapped.
        </p><p>
If the client has the active window, it should also update this property
on the window whenever there's user activity.
        </p><p>
Rationale: This property allows a Window Manager to alter the focus,
stacking, and/or placement behavior of windows when they are
mapped depending on whether the new window was created by a user
action or is a "pop-up" window activated by a timer or some other
event.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732545"></a>_NET_FRAME_EXTENTS</h3></div></div></div><pre class="programlisting">
_NET_FRAME_EXTENTS, left, right, top, bottom, CARDINAL[4]/32
</pre><p>
The Window Manager MUST set _NET_FRAME_EXTENTS to the extents of the
window's frame.  left, right, top and bottom are widths of the
respective borders added by the Window Manager.
	</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2732565"></a>Window Manager Protocols</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732570"></a>_NET_WM_PING</h3></div></div></div><p>
This protocol allows the Window Manager to determine if the Client is still
processing X events.  This can be used by the Window Manager to determine if a
window which fails to close after being sent WM_DELETE_WINDOW has stopped
responding or has stalled for some other reason, such as waiting for user
confirmation.  A Client SHOULD indicate that it is willing to participate in
this protocol by listing _NET_WM_PING in the WM_PROTOCOLS property of the
client window.
		</p><p>
A Window Manager can use this protocol at any time by sending a client message
as follows:
		</p><pre class="programlisting">
type = ClientMessage
window = the respective client window
message_type = WM_PROTOCOLS
format = 32
data.l[0] = _NET_WM_PING
data.l[1] = timestamp
data.l[2] = the respective client window
other data.l[] elements = 0
</pre><p>
A participating Client receiving this message MUST send it back to the root
window immediately, by setting window = root, and calling XSendEvent with
the same event mask like all other root window messages in this specification use.
The Client MUST NOT alter any field in the event other than the window. This
includes all 5 longs in the data.l[5] array. The Window Manager can uniquely
identify the ping by the timestamp and the data.l[2] field if necessary.
Note that some older clients may not preserve data.l[2] through data.l[4].
		</p><p>
The Window Manager MAY kill the Client (using _NET_WM_PID) if it fails to
respond to this protocol within a reasonable time.
		</p><p>
See also the implementation notes on <a class="link" href="#KILLINGWINDOWS" title="Killing Hung Processes">killing hung processes</a>.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732629"></a>_NET_WM_SYNC_REQUEST</h3></div></div></div><p>
This protocol uses the XSync extension (see <a class="ulink" href="http://freedesktop.org/cgi-bin/viewcvs.cgi/xorg/xc/doc/hardcopy/Xext/sync.PS.gz" target="_top">the
protocol specification</a> and <a class="ulink" href="http://freedesktop.org/cgi-bin/viewcvs.cgi/xorg/xc/doc/hardcopy/Xext/synclib.PS.gz" target="_top">
the library documentation</a>) to let client and window manager
synchronize the repaint of the window manager frame and the client
window. A client indicates that it is willing to participate in the
protocol by listing _NET_WM_SYNC_REQUEST in the WM_PROTOCOLS property
of the client window and storing the XID of an XSync counter in the
property _NET_WM_SYNC_REQUEST_COUNTER. The initial value of this
counter is not defined by this specification.
		</p><p>
A window manager uses this protocol by preceding a ConfigureNotify
event sent to a client by a client message as follows:
		</p><pre class="programlisting">
type = ClientMessage
window = the respective client window
message_type = WM_PROTOCOLS
format = 32
data.l[0] = _NET_WM_SYNC_REQUEST
data.l[1] = timestamp
data.l[2] = low 32 bits of the update request number
data.l[3] = high 32 bits of the update request number
other data.l[] elements = 0
</pre><p>
After receiving one or more such message/ConfigureNotify pairs, and
having handled all repainting associated with the ConfigureNotify
events, the client MUST set the _NET_WM_SYNC_REQUEST_COUNTER to the 64
bit number indicated by the data.l[2] and data.l[3] fields of the last
client message received.
		</p><p>
By using either the Alarm or the Await mechanisms of the XSync
extension, the window manager can know when the client has finished
handling the ConfigureNotify events. The window manager SHOULD not
resize the window faster than the client can keep up.
		</p><p>
The update request number in the client message is determined by the
window manager subject to the restriction that it MUST NOT be 0. The
number is generally intended to be incremented by one for each message
sent. Since the initial value of the XSync counter is not defined by
this specification, the window manager MAY set the value of the XSync
counter at any time, and MUST do so when it first manages a new
window.
		</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2732704"></a>Implementation notes</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732709"></a>Desktop/workspace model</h3></div></div></div><p>
This spec assumes a desktop model that consists of one or more completely
independent desktops which may or may not be larger than the screen area.
When a desktop is larger than the screen it is left to the Window Manager if
it will implement scrolling or paging.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732723"></a>File Manager desktop</h3></div></div></div><p>
This spec suggests implementing the file manager desktop by mapping a
desktop-sized window (no shape) to all desktops, with
_NET_WM_WINDOW_TYPE_DESKTOP.  This makes the desktop focusable and greatly
simplifies implementation of the file manager.  It is also faster than
managing lots of small shaped windows. The file manager draws the background
on this window.  There should be a root property with a window handle for use
in applications that want to draw the background (xearth).
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732741"></a>Implementing enhanced support for application transient windows</h3></div></div></div><p>
If the WM_TRANSIENT_FOR property is set to None or Root window, the window
should be treated as a transient for all other windows in the same group.  It
has been noted that this is a slight ICCCM violation, but as this behavior is
pretty standard for many toolkits and window managers, and is extremely
unlikely to break anything, it seems reasonable to document it as standard.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="URGENCY"></a>Urgency</h3></div></div></div><p>
Windows expecting immediate user action should indicate this using the
urgency bit in the WM_HINTS.flags property, as defined in the ICCCM.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="NORESIZE"></a>Fixed size windows</h3></div></div></div><p>
	Windows can indicate that they are non-resizable by setting minheight = maxheight and minwidth = maxwidth in the ICCCM WM_NORMAL_HINTS property.  The Window Manager MAY decorate such windows differently.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732788"></a>Pagers and Taskbars</h3></div></div></div><p>
	This specification attempts to make reasonable provisions for window
	manager independent pagers and taskbars.  Window Managers that require
	/ desire additional functionality beyond what can be achieved using the
	mechanisms set out in this specification may choose to implement their
	own pagers, which communicate with the Window Manager using further,
	window manager specific hints, or some other means.
	</p><p>
        Pagers should decide whether to show a miniature version of a
        window using the following guidelines:
          </p><div class="itemizedlist"><ul type="disc"><li><p>
                If either _NET_WM_STATE_SKIP_PAGER or
                _NET_WM_STATE_HIDDEN are set on a window, then the
                pager should not show that window.
              </p></li><li><p>
                The pager may choose not to display windows with 
                certain semantic types; this spec has no
                recommendations, but common practice is to avoid 
                displaying _NET_WM_WINDOW_TYPE_DOCK for example.
              </p></li><li><p>
                If the _NET_WM_STATE_SKIP_PAGER and
                _NET_WM_STATE_HIDDEN hints are not present, and the
                Window Manager claims to support _NET_WM_STATE_HIDDEN,
                then the window should be shown if it's in either
                NormalState or IconicState.
              </p></li><li><p>
                For Window Managers that do not support
                _NET_WM_STATE_HIDDEN, the pager should 
                not show windows in IconicState. These Window 
                Managers are probably using an older version 
                of this specification.
              </p></li></ul></div><p>
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2732857"></a>Window Geometry</h3></div></div></div><p>
Window manager implementors should refer to the ICCCM for definitive
specifications of how to handle MapRequest and ConfigureRequest events.
However, since these aspects of the ICCCM are easily misread, this
document offers the following clarifications:
	</p><div class="itemizedlist"><ul type="disc"><li><p>
Window Managers MUST honor the win_gravity field of WM_NORMAL_HINTS
for both MapRequest <span class="emphasis"><em>and</em></span> ConfigureRequest events 
(ICCCM Version 2.0, 4.1.2.3 and 4.1.5)
		</p></li><li><p>
When generating synthetic ConfigureNotify events, the position given
MUST be the top-left corner of the client window in relation to the
origin of the root window (i.e., ignoring win_gravity) 
(ICCCM Version 2.0, 4.2.3)
		</p></li><li><p>
Window Managers maintain a reference point for each client window and place 
the window relative to this reference point depending on the window's 
win_gravity as follows:
		</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>win_gravity:</td><td>placed at the reference point</td></tr><tr><td>StaticGravity</td><td>the left top corner of the client window</td></tr><tr><td>NorthWestGravity</td><td>the left top corner of the frame window</td></tr><tr><td>NorthGravity</td><td>the center of the frame window's top side</td></tr><tr><td>NorthEastGravity</td><td>the right top corner of the frame window</td></tr><tr><td>EastGravity</td><td>the center of the frame window's right side</td></tr><tr><td>SouthEastGravity</td><td>the right bottom corner of the frame window</td></tr><tr><td>SouthGravity</td><td>the center of the frame window's bottom side</td></tr><tr><td>SouthWestGravity</td><td>the left bottom corner of the frame window</td></tr><tr><td>WestGravity</td><td>the center of the frame window's left side</td></tr><tr><td>CenterGravity</td><td>the center of the frame window</td></tr></tbody></table></div></li><li><p>
Applications are free to change their win_gravity setting at any time.
		</p><p>
If an Application changes its win_gravity then the Window Manager should 
adjust the reference point, so that the client window will not move as the 
result. For example if the Application's win_gravity was NorthWestGravity and 
reference point was at the top-left corner of the frame window, then after 
change of win_gravity to SouthEastGravity the reference point should be 
adjusted to point to the lower-right corner of the frame.
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p> 
Changing the win_gravity for a single configure request and back afterwards is
unlikely to work as intended, due to a race condition. The window manager sees
a property notify for WM_NORMAL_HINTS, followed by the configure request,
followed by another property notify for WM_NORMAL_HINTS. By the time the
window manager gets around to request the changed WM_NORMAL_HINTS in response
to the first property notify, the server may have already processed the second
property change.  
                </p><p>
If the window manager supports it, applications should use 
_NET_MOVERESIZE_WINDOW with a specified gravity to avoid this problem.
                </p></div></li><li><p>
If the Application requests a new position (x, y) (and possibly also a 
new size), the Window Manager calculates a new reference point (ref_x, ref_y),
based on the client window's (possibly new) size (width, height), border 
width (bw) and win_gravity as explained in the table below.
                </p><p>
The Window Manager will use the new reference point until the next request for 
a new position. 
		</p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>win_gravity:</td><td>ref_x:</td><td>ref_y:</td></tr><tr><td>StaticGravity</td><td>x</td><td>y</td></tr><tr><td>NorthWestGravity</td><td>x-bw</td><td>y-bw</td></tr><tr><td>NorthGravity</td><td>x+(width/2)</td><td>y-bw</td></tr><tr><td>NorthEastGravity</td><td>x+width+bw</td><td>y-bw</td></tr><tr><td>EastGravity</td><td>x+width+bw</td><td>y+(height/2)</td></tr><tr><td>SouthEastGravity</td><td>x+width+bw</td><td>y+height+bw</td></tr><tr><td>SouthGravity</td><td>x+(width/2)</td><td>y+height+bw</td></tr><tr><td>SouthWestGravity</td><td>x-bw</td><td>y+height+bw</td></tr><tr><td>WestGravity</td><td>x-bw</td><td>y+(height/2)</td></tr><tr><td>CenterGravity</td><td>x+(width/2)</td><td>y+(height/2)</td></tr></tbody></table></div></li><li><p>
If an Application requests just a new size, its reference point does not 
move. So for example if client window has win_gravity SouthEastGravity and 
is resized, the bottom right corner of its frame will not move but instead
the top left corner will be adjusted by the difference in size.
		</p></li><li><p>
When calculating the reference point at the time of initial placement,
the Window Manager should take the initial window's size into consideration, 
as if it was the frame for this window.
		</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2733264"></a>Window-in-Window MDI</h3></div></div></div><p>
	The authors of this specification acknowledge that there is no standard
	method to allow the Window Manager to manage windows that are part of a
	Window-in-Window MDI application.  Application authors are advised to
	use some other form of MDI, or to propose a mechanism to be included in
	a future revision of this specification.
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="KILLINGWINDOWS"></a>Killing Hung Processes</h3></div></div></div><p>
If processes fail to respond to the _NET_WM_PING protocol _NET_WM_PID may be
used in combination with the ICCCM specified WM_CLIENT_MACHINE to 
attempt to kill a process.
		</p><p>
WM_CLIENT_MACHINE is usually set by calling XSetWMProperties(). The hostname for the current host can be be retrieved using gethostname(), when gethostname()
is not available on the platform implementors may use the value of the
nodename field of struct utsname as returned by uname(). Note also that the value of WM_CLIENT_MACHINE is not guaranteed
to be a fully fully-qualified domain name of the host. An example of how to
retrieve the hostname:
		</p><p>
	</p><pre class="programlisting">
int net_get_hostname (char *buf, size_t maxlen)
{
#ifdef HAVE_GETHOSTNAME
	if (buf == NULL) return 0;

	gethostname (buf, maxlen);
	buf [maxlen - 1] = '\0';

	return strlen(buf);
#else
	struct utsname name;
	size_t len;

	if (buf == NULL) return 0;

	uname (&amp;name);
	len = strlen (name.nodename);

	if (len &gt;= maxlen) len = maxlen - 1;
	strncpy (buf, name.nodename, len);
	buf[len] = '\0';

	return len;
#endif
}
</pre><p>
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="STACKINGORDER"></a>Stacking order</h3></div></div></div><p>
	To obtain good interoperability between different Desktop Environments,
	the following layered stacking order is recommended, from the bottom:
	</p><div class="itemizedlist"><ul type="disc"><li><p>windows of type _NET_WM_TYPE_DESKTOP</p></li><li><p>windows having state _NET_WM_STATE_BELOW</p></li><li><p>windows not belonging in any other layer</p></li><li><p>windows of type _NET_WM_TYPE_DOCK (unless they have
	      state _NET_WM_TYPE_BELOW) and windows having state
	      _NET_WM_STATE_ABOVE</p></li><li><p>focused windows having state
	      _NET_WM_STATE_FULLSCREEN</p></li></ul></div><p>
      </p><p>
	Windows that are transient for another window should be kept 
	above this window.
      </p><p>
	The window manager may choose to put some windows in different 
	stacking positions, for example to allow the user to bring currently
	a active window to the top and return it back when the window looses
	focus.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sourceindication"></a>Source indication in requests</h3></div></div></div><p>
          Some requests from Clients include type of the Client, for example
          the _NET_ACTIVE_WINDOW message. Currently the types can be
          1 for normal applications, and 2 for pagers and other Clients
          that represent direct user actions (the Window Manager may decide
          to treat requests from applications differently than requests
          that are result of direct user actions).
          Clients that support only older version of this spec will have 0
          as their source indication, thus not specifying their source at all.
          This also may mean that some of the fields in the message comply
          only with the older specification version.
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2733403"></a>References</h2></div></div></div><div class="variablelist"><dl><dt><span class="term">[UTF8]</span></dt><dd><p><a name="UTF8"></a>
      F. Yergeau,"UTF-8, a transformation format of ISO 10646", RFC 2279
    </p></dd><dt><span class="term">[ICCCM]</span></dt><dd><p><a name="ICCCM"></a>
      David Rosenthal and Stuart W. Marks, "Inter-Client Communication
      Conventions Manual (Version 2.0)", X Consortium Standard, X Version 11,
      Release 6.3
    </p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2733447"></a>Copyright</h2></div></div></div><p>
Copyright (C) 2000-2003 See Contributors List
    </p><p> 
Permission  is hereby granted, free of charge, to any person
obtaining a copy of this software and associated  documentation 
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons  to  whom
the Software is furnished to do so, subject to the following
conditions:
    </p><p> 
The above copyright notice and this permission notice  shall
be  included  in  all  copies or substantial portions of the
Software.
    </p><p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT  WARRANTY  OF  ANY
KIND,  EXPRESS  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
AND  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS
BE LIABLE FOR ANY CLAIM, DAMAGES  OR  OTHER  LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR  THE  USE
OR OTHER DEALINGS IN THE SOFTWARE.  
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2733485"></a>Contributors</h2></div></div></div><p>Sasha Vasko</p><p>Bradley T. Hughes</p><p>Dominik Vogt</p><p>Havoc Pennington</p><p>Jeff Raven</p><p>Jim Gettys</p><p>John Harper</p><p>Julian Adams</p><p>Matthias Ettrich</p><p>Micheal Rogers</p><p>Nathan Clemons</p><p>Tim Janik</p><p>Tomi Ollila</p><p>Sam Lantinga</p><p>The Rasterman</p><p>Paul Warren</p><p>Owen Taylor</p><p>Marko Macek</p><p>Greg Badros</p><p>Matthias Clasen</p><p>David Rosenthal</p><p>Lubos Lunak</p><p>Rob Adams</p><p>Thomas Fitzsimmons</p><p>Olivier Chapuis</p><p>Sren Sandmann</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2733572"></a>Change history</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2733578"></a>Changes since 1.2</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
Added source indication to _NET_CLOSE_WINDOW, _NET_WM_MOVERESIZE,
_NET_MOVERESIZE_WINDOW, _NET_WM_DESKTOP and _NET_WM_STATE message.
			</p></li><li><p>
Added _NET_WM_SYNC_REQUEST to allow synchronized repaint of
application window and window manager frame during opaque resize.
			</p></li><li><p>
Added _NET_REQUEST_FRAME_EXTENTS and _NET_FRAME_EXTENTS to allow a
client to retrieve its window's frame extents.
 			</p></li><li><p>
Added new state _NET_WM_STATE_DEMANDS_ATTENTION.
 			</p></li><li><p>
Added timestamp, source indication and requestor's active window
fields to the _NET_ACTIVE_WINDOW message.
 			</p></li><li><p>
Added _NET_RESTACK_WINDOW message.
 			</p></li><li><p>
Added new property _NET_WM_STRUT_PARTIAL to allow partial-width struts.
 			</p></li><li><p>
Rewrote the implementation notes on "Window Movement", retitled it 
to "Window Geometry".
 			</p></li><li><p>
Rewrote the implementation notes on "Urgency", making it clear that
the hint is not just about dialogs.
 			</p></li><li><p>
Fixed the specification of the X and Y members of _NET_DESKTOP_LAYOUT
and renamed them to columns and row for clarity.
 			</p></li><li><p>
Change the description of _NET_WM_STATE_MODAL to no longer require apps to 
break the ICCCM for group-modal windows, but still support the 
WM_TRANSIENT_FOR=root dialect.
 			</p></li><li><p>
Specified that (yet) unused fields in client messages must be set to 0.
                        </p></li><li><p>
_NET_WM_PING message now has the client window identified in data.l[2] field.
                        </p></li><li><p>
Added _NET_WM_USER_TIME to detect user activity in windows.
                        </p></li><li><p>
Explicitly specify that the window manager should restore original geometry
when _NET_WM_STATE_FULLSCREEN is reset.
                        </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2733686"></a>Changes since 1.1</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
 Changed WM_CLIENT_NAME(STRING) from suggested to required for _NET_WM_PID.
 			</p></li><li><p>
 Specification and sample code for the content of WM_CLIENT_NAME(STRING).
 			</p></li><li><p>
 Added _NET_WM_WINDOW_TYPE_SPLASH, _NET_WM_WINDOW_TYPE_UTILITY.
 			</p></li><li><p>
 Added _NET_WM_STATE_FULLSCREEN.
 			</p></li><li><p>
 Added _NET_WM_ALLOWED_ACTIONS.
 			</p></li><li><p>
 Added _NET_WM_STATE_HIDDEN and clarified purpose of
 _NET_WM_STATE_SKIP_PAGER and _NET_WM_STATE_SKIP_TASKBAR. Changed
 section on virtual desktop implementation to suggest ICCCM compliance
 regarding IconicState, using _NET_WM_STATE_HIDDEN to avoid confusion.
 Added implementation note for pagers on when to display a window.
 			</p></li><li><p>
 Added button field and new directions for keyboard-initiated actions
 to the _NET_WM_MOVERESIZE message. 
 			</p></li><li><p>
 Added advice on removing _NET_WM_STATE and _NET_WM_DESKTOP when a window 
 is withdrawn.
 			</p></li><li><p>
 Added _NET_DESKTOP_LAYOUT to allow a Pager to specify inter-desktop geometry.
 			</p></li><li><p>
 Added _NET_SHOWING_DESKTOP. 
 			</p></li><li><p>
 Added _NET_WM_STATE_ABOVE and _NET_WM_STATE_BELOW and a recommended layered 
 stacking order. 
 			</p></li><li><p>
 Added _NET_MOVERESIZE_WINDOW.
 			</p></li><li><p>
 Improve markup of citations. 
 			</p></li><li><p>
 Explain _NET_DESKTOP_GEOMETRY and _NET_WM_HANDLED_ICONS in more detail and
 improve the explanation of WM_CLIENT_MACHINE in 
 <a class="xref" href="#KILLINGWINDOWS" title="Killing Hung Processes">the section called &#8220;Killing Hung Processes&#8221;</a>. 
 			</p></li><li><p>
 Add Lubos Lunak to the list of contributors.
 			</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2733787"></a>Changes since 1.0</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
Fix doctype, add author info, update data.
			</p></li><li><p>
Change specification description wording to be more inclusive, and to reflect the joint nature of the specification.
			</p></li><li><p>
Fix miscellaneous typographical, grammar and spelling errors.
			</p></li><li><p>
Clarified _NET_SUPPORTED to include ALL atoms, not just the property names.
			</p></li><li><p>
Various corrections to use of MUST and SHOULD.
			</p></li><li><p>
Fix problem in _NET_WM_ICON where 'bytes' should have been 'cardinals'
			</p></li><li><p>
Replaced ISO-8559-1 characters with entities.
			</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2733835"></a>Changes since 1.0pre5</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
Change history moved to end.
			</p></li><li><p>
UTF-8 Reference updated.
			</p></li><li><p>
Window Gravity information updated.
			</p></li><li><p>
Copyright Added.
			</p></li><li><p>
Minor typo corrections.
			</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2733867"></a>Changes since 1.0pre4</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
Clarified the interpretation of client-provided geometries on large desktops.
			</p></li><li><p>
Added more explanation for _NET_DESKTOP_NAMES. 
			</p></li><li><p>
Added _NET_WM_ICON_NAME and _NET_WM_VISIBLE_ICON_NAME.
			</p></li><li><p>
Tried to improve the wording of _NET_WM_STRUT explanation.
			</p></li><li><p>
Changed _NET_WORKAREA to an array of viewport-relative geometries.
			</p></li><li><p>
Updated list of &#8220;<span class="quote">dependent</span>&#8221; properties for _NET_NUMBER_OF_DESKTOPS
to include _NET_WORKAREA and _NET_DESKTOP_VIEWPORT.
			</p></li><li><p>
Tidied formatting of all client messages.
			</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2733918"></a>Changes since 1.0pre3</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
Added information about common non-ICCCM features.
			</p></li><li><p>
Added explanation of sending messages to the root window.
			</p></li><li><p>
Removed XA_ prefix from type names.
			</p></li><li><p>
Clarified that &#8220;<span class="quote">mapping order</span>&#8221; refers to inital mapping 
and specify the directions of both orders.
			</p></li><li><p>
Clarified that desktops have a common size specified by _NET_DESKTOP_GEOMETRY.
			</p></li><li><p>
Rewrote explanation of _NET_DESKTOP_VIEWPORT.
			</p></li><li><p>
Tidied formatting of _NET_CURRENT_DESKTOP.
			</p></li><li><p>
Replaced &#8220;<span class="quote">window handle</span>&#8221; by &#8220;<span class="quote">window ID</span>&#8221;.
			</p></li><li><p>
Tidied formatting of _NET_WORKAREA.
			</p></li><li><p>
Rewrote the motivation for _NET_VIRTUAL_ROOTS.
			</p></li><li><p>
Added advice on Pointer grabs to _NET_WM_MOVERESIZE.
			</p></li><li><p>
Fixed typos in _NET_WM_STATE.
			</p></li><li><p>
Added _NET_WM_STATE_SKIP_PAGER.
			</p></li><li><p>
Tidied formatting of _NET_WM_STRUT.
			</p></li><li><p>
Tidied formatting of _NET_WM_ICON_GEOMETRY.
			</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2734014"></a>Changes since 1.0pre2</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
_NET_SET_NUMBER_OF_DESKTOPS -&gt; _NET_NUMBER_OF_DESKTOPS for consistency.
			</p></li><li><p>
_NET_WM_VISIBLE_NAME_STRING -&gt; _NET_WM_VISIBLE_NAME for consistency.
			</p></li><li><p>
_NET_WM_STATE: added explanation of permitted extensions. Added explanation of 
being set / not set.
			</p></li><li><p>
Spellchecked, corrected various typos.
			</p></li><li><p>
UTF8 -&gt; UTF-8 for consistency.
			</p></li><li><p>
added references to the ICCCM an UTF-8 (incomplete).
			</p></li><li><p>
added data and event formats where missing.
			</p></li><li><p>
clarified _NET_SUPPORTING_WM_CHECK.
			</p></li><li><p>
fixed formatting of _NET_CLOSE_WINDOW message.
			</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2734072"></a>Changes since 1.0pre1</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
Removed implementation note concerning Gnome's (potential) file manager behavior.
			</p></li><li><p>
The Window Movement section of the implementation notes has been revised.
			</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2734093"></a>Changes since 1.9f</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
Revised revision number for first accepted release 1.9XX -&gt; 1.0preXX.
			</p></li><li><p>
Prerequisites for adoption of this specification added.
			</p></li><li><p>
Tidied formatting of _NET_CURRENT_DESKTOP for consistency.
			</p></li><li><p>
Tidied formatting of _NET_ACTIVE_WINDOW  for consistency. Removed doubled text.
			</p></li><li><p>
Tidied formatting of _NET_WM_DESKTOP for consistency.
			</p></li><li><p>
Killing Hung Processes implementation note added. _NET_WM_PID and _NET_WM_PING now link to this.
			</p></li><li><p>
Clarified x_root and y_root meaning for _NET_WM_MOVERESIZE.
			</p></li><li><p>
Added contributor list.
			</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2734146"></a>Changes since 1.9e</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
Added _NET_WM_VISIBLE_NAME_STRING
			</p></li><li><p>
Removed ambiguity from _NET_NUMBER_OF_DESKTOPS and  _NET_DESKTOP_NAMES in combination.
			</p></li><li><p>
Set _NET_WM_MOVERESIZE format to 32 for consistency.
			</p></li><li><p>
Removed _NET_PROPERTIES.
			</p></li><li><p>
Removed comment from _NET_WM_MOVERESIZE.
			</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2734181"></a>Changes since 1.9d</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
Added _NET_VIRTUAL_ROOTS
			</p></li><li><p>
Added note about ICCCM compliant window moves.
			</p></li><li><p>
Added _NET_WM_HANDLED_ICONS
			</p></li><li><p>
Added _NET_SUPPORTING_WM_CHECK
			</p></li><li><p>
Removed degrees of activation
			</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2734213"></a>Changes since 1.9c</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
Removed packaging of hints into 2 X properties.  Jim Gettys points out that the
performance gains of fewer round trips can be better achieved using Xlib
routines.
				</p></li><li><p>
Clarified that _NET_DESKTOP_VIEWPORT is in pixels
				</p></li><li><p>
_NET_DESKTOP_VIEWPORT is now an array, one for each desktop, to allow for
different active viewports on different desktops
				</p></li><li><p>
_NET_WM_STRUT now only applies on desktops on which the client is visible
				</p></li><li><p>
Introduced RFC 2119 language, and attempted to clarify the roles of the Window
Manager, Pagers and Applications
				</p></li><li><p>
Added _NET_WM_NAME
				</p></li><li><p>
_NET_DESKTOP_NAMES now in UTF8
				</p></li><li><p>
Desktops now start from 0
				</p></li><li><p>
Added _NET_WM_PID
				</p></li><li><p>
Added _NET_WM_PING protocol
				</p></li><li><p>
Added _NET_WM_STATE_SKIP_TASKBAR
				</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2734305"></a>Changes since 1.9b</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Removed _NET_NUMBER_OF_DESKTOPS client message, as it overlaps unnecessarily with _NET_{INSERT/DELETE}_DESKTOP.</p></li><li><p>Replaced _NET_WM_LAYER and _NET_WM_HINTS with _NET_WM_WINDOW_TYPE functional hint.</p></li><li><p>Changed _NET_WM_STATE to a list of atoms, for extensibility.</p></li><li><p>Expanded description of _NET_WORKAREA and _NET_WM_STRUT.</p></li><li><p>Removed _NET_WM_SIZEMOVE_NOTIFY protocol. </p></li><li><p>Added degrees of activation to _NET_ACTIVE_WINDOW client message</p></li><li><p>Added _NET_WM_ICON</p></li><li><p>My comments are in [[ ]].  Comments from Marko's draft are in [[MM: ]]</p></li></ul></div></div></div></div></body></html>
